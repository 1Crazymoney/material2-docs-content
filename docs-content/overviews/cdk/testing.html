<div class="docs-markdown"><p><code>@angular/cdk/testing</code> provides infrastructure to help with testing Angular components.</p>

        <h3 id="component-test-harnesses" class="docs-header-link">
          <span header-link="component-test-harnesses"></span>
          Component test harnesses
        </h3>
      <p>A component harness is a class that lets a test interact with a component via a supported API.
Each harness&#39;s API interacts with a component the same way a user would. By using the harness API,
a test insulates itself against updates to the internals of a component, such as changing its DOM
structure. The idea for component harnesses comes from the
<a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a> pattern commonly used for integration
testing.</p>
<p><code>@angular/cdk/testing</code> contains infrastructure for creating and using component test harnesses. You
can create test harnesses for any component, ranging from small reusable widgets to full application
pages. </p>
<p>The component harness system supports multiple testing environments. You can use the same harness
implementation in both unit and end-to-end tests. This means that users only need to learn one API,
and component authors don&#39;t have to maintain separate unit and end-to-end test implementations.</p>
<p>Common component libraries, in particular, benefit from this infrastructure due to the wide use of
their components. Providing a test harness allows the consumers of a component to write tests that
avoid dependencies on any private implementation details. By capturing these implementation details
in a single place, consumers can more easily update to new library versions.</p>
<p>This document provides guidance for three types of developers:</p>
<ol>
<li><a href="#api-for-test-authors">Test authors</a></li>
<li><a href="#api-for-component-harness-authors">Component harness authors</a></li>
<li><a href="#api-for-harness-environment-authors">Harness environment authors</a></li>
</ol>
<p>Since many developers fall into only one of these categories, the relevant APIs are broken out by
developer type in the sections below.</p>

        <h3 id="api-for-test-authors" class="docs-header-link">
          <span header-link="api-for-test-authors"></span>
          API for test authors
        </h3>
      <p>Test authors are developers using component harnesses written by someone else to test their
application. For example, this could be an app developer who uses a third-party menu component and
needs to interact with the menu in a unit test.</p>

        <h4 id="-code-componentharness-code-" class="docs-header-link">
          <span header-link="-code-componentharness-code-"></span>
          <code>ComponentHarness</code>
        </h4>
      <p>This is the abstract base class for all component harnesses. Every harness extends
<code>ComponentHarness</code>. All <code>ComponentHarness</code> subclasses have a static property, <code>hostSelector</code>, that
matches the harness class to instances of the component in the DOM. Beyond that, the API of any
given harness is specific to its corresponding component; refer to the component&#39;s documentation to
learn how to use a specific harness.</p>

        <h4 id="-code-testbedharnessenvironment-code-and-code-protractorharnessenvironment-code-" class="docs-header-link">
          <span header-link="-code-testbedharnessenvironment-code-and-code-protractorharnessenvironment-code-"></span>
          <code>TestbedHarnessEnvironment</code> and <code>ProtractorHarnessEnvironment</code>
        </h4>
      <p>These classes correspond to different implementations of the component harness system with bindings
for specific test environments. Any given test must only import <em>one</em> of these classes. Karma-based
unit tests should use the <code>TestbedHarnessEnvironment</code>, while Protractor-based end-to-end tests
should use the <code>ProtractorHarnessEnvironment</code>. Additional environments require custom bindings; see
<a href="#api-for-harness-environment-authors">API for harness environment authors</a> for more information on
alternate test environments.</p>
<p>These classes are primarily used to create a <code>HarnessLoader</code> instance, and in certain cases, to
create <code>ComponentHarness</code> instances directly.</p>
<p><code>TestbedHarnessEnvironment</code> offers the following static methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>loader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the fixture&#39;s root element. Should be used to create harnesses for elements contained inside the fixture</td>
</tr>
<tr>
<td><code>documentRootLoader(fixture: ComponentFixture&lt;unknown&gt;): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the given fixture, rooted at the HTML document&#39;s root element. Can be used to create harnesses for elements that fall outside of the fixture</td>
</tr>
<tr>
<td><code>harnessForFixture&lt;T extends ComponentHarness&gt;(fixture: ComponentFixture&lt;unknown&gt;, harnessType: ComponentHarnessConstructor&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td>Used to create a <code>ComponentHarness</code> instance for the fixture&#39;s root element directly. This is necessary when bootstrapping the test with the component you plan to load a harness for, because Angular does not set the proper tag name when creating the fixture.</td>
</tr>
</tbody></table>
<p>In most cases, you can create a <code>HarnessLoader</code> in the <code>beforeEach</code> block using
<code>TestbedHarnessEnvironment.loader(fixture)</code> and then use that <code>HarnessLoader</code> to create any
necessary <code>ComponentHarness</code> instances. The other methods cover special cases as shown in this
example:  </p>
<p>Consider a reusable dialog-button component that opens a dialog on click, containing the following
components, each with a corresponding harness:</p>
<ul>
<li><code>MyDialogButton</code> (composes the <code>MyButton</code> and <code>MyDialog</code> with a convenient API)</li>
<li><code>MyButton</code> (a simple button component)</li>
<li><code>MyDialog</code> (a dialog appended to <code>document.body</code> by <code>MyButtonDialog</code> upon click)</li>
</ul>
<p>The following code loads harnesses for each of these components:</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> fixture: ComponentFixture&lt;MyDialogButton&gt;;
<span class="hljs-keyword">let</span> loader: HarnessLoader;
<span class="hljs-keyword">let</span> rootLoader: HarnessLoader;

beforeEach(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  fixture = TestBed.createComponent(MyDialogButton);
  loader = TestbedHarnessEnvironment.loader(fixture);
  rootLoader = TestbedHarnessEnvironment.documentRootLoader(fixture);
});

it(<span class="hljs-string">'loads harnesses'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-comment">// Load a harness for the bootstrapped component with `harnessForFixture`</span>
  dialogButtonHarness =
      <span class="hljs-keyword">await</span> TestbedHarnessEnvironment.harnessForFixture(fixture, MyDialogButtonHarness);

  <span class="hljs-comment">// The button element is inside the fixture's root element, so we use `loader`.</span>
  <span class="hljs-keyword">const</span> buttonHarness = <span class="hljs-keyword">await</span> loader.getHarness(MyButtonHarness);

  <span class="hljs-comment">// Click the button to open the dialog</span>
  <span class="hljs-keyword">await</span> buttonHarness.click();

  <span class="hljs-comment">// The dialog is appended to `document.body`, outside of the fixture's root element,</span>
  <span class="hljs-comment">// so we use `rootLoader` in this case.</span>
  <span class="hljs-keyword">const</span> dialogHarness = <span class="hljs-keyword">await</span> rootLoader.getHarness(MyDialogHarness);

  <span class="hljs-comment">// ... make some assertions</span>
});</code></pre>
<p><code>ProtractorHarnessEnvironment</code> has an API that offers a single static method:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>loader(): HarnessLoader</code></td>
<td>Gets a <code>HarnessLoader</code> instance for the current HTML document, rooted at the document&#39;s root element.</td>
</tr>
</tbody></table>
<p>Since Protractor does not deal with fixtures, the API in this environment is simpler. The
<code>HarnessLoader</code> returned by the <code>loader()</code> method should be sufficient for loading all necessary
<code>ComponentHarness</code> instances.</p>

        <h4 id="-code-harnessloader-code-" class="docs-header-link">
          <span header-link="-code-harnessloader-code-"></span>
          <code>HarnessLoader</code>
        </h4>
      <p>Instances of this class correspond to a specific DOM element (the &quot;root element&quot; of the loader) and
are used to create <code>ComponentHarness</code> instances for elements under this root element.</p>
<p><code>HarnessLoader</code> instances have the following methods:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><code>getChildLoader(selector: string): Promise&lt;HarnessLoader&gt;</code></td>
<td>Searches for an element matching the given selector below the root element of this <code>HarnessLoader</code>, and returns a new <code>HarnessLoader</code> rooted at the first matching element</td>
</tr>
<tr>
<td><code>getAllChildLoaders(selector: string): Promise&lt;HarnessLoader[]&gt;</code></td>
<td>Acts like <code>getChildLoader</code>, but returns an array of <code>HarnessLoader</code> instances, one for each matching element, rather than just the first matching element</td>
</tr>
<tr>
<td><code>getHarness&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T&gt;</code></td>
<td>Searches for an instance of the given <code>ComponentHarness</code> class or <code>HarnessPredicate</code> below the root element of this <code>HarnessLoader</code> and returns an instance of the harness corresponding to the first matching element</td>
</tr>
<tr>
<td><code>getAllHarnesses&lt;T extends ComponentHarness&gt;(harnessType: ComponentHarnessConstructor&lt;T&gt; | HarnessPredicate&lt;T&gt;): Promise&lt;T[]&gt;</code></td>
<td>Acts like <code>getHarness</code>, but returns an array of harness instances, one for each matching element, rather than just the first matching element</td>
</tr>
</tbody></table>
<p>Calls to <code>getHarness</code> and <code>getAllHarnesses</code> can either take <code>ComponentHarness</code> subclass or a 
<code>HarnessPredicate</code>. <code>HarnessPredicate</code> applies additional restrictions to the search (e.g. searching
for a button that has some particular text, etc). The
<a href="#harnesspredicate">details of <code>HarnessPredicate</code></a> are discussed in the
<a href="#api-for-component-harness-authors">API for component harness authors</a>; harness authors should
provide convenience methods on their <code>ComponentHarness</code> subclass to facilitate creation of
<code>HarnessPredicate</code> instances. However, if the harness author&#39;s API is not sufficient, they can be
created manually.</p>

        <h4 id="working-with-asynchronous-component-harness-methods" class="docs-header-link">
          <span header-link="working-with-asynchronous-component-harness-methods"></span>
          Working with asynchronous component harness methods
        </h4>
      <p>In order to support both unit and end-to-end tests, and to insulate tests against changes in
asynchronous behavior, almost all harness methods are asynchronous and return a <code>Promise</code>;
therefore, the Angular team recommends using 
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">ES2017 <code>async</code>/<code>await</code> syntax</a>
to improve the test readability.</p>
<p>Note that <code>await</code> statements block the execution of your test until the associated <code>Promise</code>
resolves. When reading multiple properties off a harness it may not be necessary to block on the
first before asking for the next, in these cases use <code>Promise.all</code> to parallelize.</p>
<p>For example, consider the following example of reading both the <code>checked</code> and <code>indeterminate</code> state
off of a checkbox harness:</p>
<pre><code class="language-ts">it(<span class="hljs-string">'reads properties in parallel'</span>, <span class="hljs-keyword">async</span> () =&gt; {
  <span class="hljs-keyword">const</span> checkboxHarness = loader.getHarness(MyCheckboxHarness);
  <span class="hljs-keyword">const</span> [checked, indeterminate] = <span class="hljs-keyword">await</span> <span class="hljs-built_in">Promise</span>.all([
    checkboxHarness.isChecked(),
    checkboxHarness.isIndeterminate()
  ]);

  <span class="hljs-comment">// ... make some assertions</span>
});</code></pre>

        <h3 id="api-for-component-harness-authors" class="docs-header-link">
          <span header-link="api-for-component-harness-authors"></span>
          API for component harness authors
        </h3>
      <p>TODO(mmalerba): Fill in docs for harness authors</p>

        <h4 id="-code-harnesspredicate-code-" class="docs-header-link">
          <span header-link="-code-harnesspredicate-code-"></span>
          <code>HarnessPredicate</code>
        </h4>
      <p>TODO(mmalerba): Fill in docs for <code>HarnessPredicate</code></p>

        <h3 id="api-for-harness-environment-authors" class="docs-header-link">
          <span header-link="api-for-harness-environment-authors"></span>
          API for harness environment authors
        </h3>
      <p>TODO(mmalerba): Fill in docs for harness environment authors</p>
</div>